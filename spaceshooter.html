<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Shooter</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    body {
      margin: 0;
      background: #000;
      font-family: 'Orbitron', sans-serif;
      color: white;
      text-align: center;
      overflow-y: auto;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background-color: #000;
    }
    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: none;
      overflow: hidden;
    }
    .hud {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 1.2em;
      z-index: 5;
    }
    .level-hud {
      top: 40px;
    }
    .lives-hud {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 1.2em;
      z-index: 5;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .heart {
      width: 30px;
      height: 30px;
      fill: #ff3333;
      filter: drop-shadow(0 0 5px rgba(255, 51, 51, 0.8));
    }
    #gameOverlay, #startScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 10;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease-in-out;
    }
    #gameOverlay.show {
      opacity: 1;
      pointer-events: auto;
    }
    #startScreen.show {
      position: relative;
      opacity: 1;
      pointer-events: auto;
      background-color: transparent;
    }
    #overlayMessage {
      font-size: 3em;
      font-weight: bold;
      margin-bottom: 20px;
      color: #fff;
    }
    #overlayScore {
      font-size: 1.5em;
      color: #fff;
    }
    #overlayRestart, #continueButton, #missionCompleteButton, .ship-selection button {
      font-size: 1.2em;
      margin-top: 20px;
      padding: 10px 20px;
      background-color: #22aaff;
      color: #fff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      transition: background-color 0.3s, transform 0.1s;
    }
    #overlayRestart:hover, #continueButton:hover, #missionCompleteButton:hover, .ship-selection button:hover {
      background-color: #0077cc;
    }
    #overlayRestart:active, #continueButton:active, #missionCompleteButton:active, .ship-selection button:active {
      transform: translateY(2px);
    }
    .power-up-timer {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1em;
      color: #fff;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 5px;
      display: none;
    }
    .power-up-timer.show {
        display: block;
    }
    #loadingOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
        transition: opacity 0.5s ease-in-out;
    }
    #loadingMessage {
        font-size: 2em;
        font-weight: bold;
        color: #fff;
    }
    .ship-selection {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        min-height: 100vh;
        justify-content: center;
    }
    .ship-options {
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 20px;
        margin-top: 30px;
    }
    .ship-card {
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid #22aaff;
        border-radius: 12px;
        padding: 20px;
        text-align: center;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        width: 80%;
        max-width: 300px;
        margin: 0 auto;
    }
    .ship-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 0 20px #22aaff;
    }
    .ship-card img {
        width: 80px;
        height: 80px;
        object-fit: contain;
    }
    .ship-card h3 {
        font-size: 1.2em;
        margin: 10px 0;
    }
    .ship-card p {
        font-size: 0.8em;
        margin: 5px 0;
    }
    .select-button {
        margin-top: 15px;
        padding: 8px 16px;
        background-color: #22aaff;
        border: none;
        border-radius: 6px;
        cursor: pointer;
    }
    @media (min-width: 768px) {
      .ship-options {
          flex-direction: row;
      }
      .ship-card {
          width: 250px;
          max-width: none;
      }
      .ship-card img {
          width: 100px;
          height: 100px;
      }
      .ship-card h3 {
          font-size: 1.5em;
      }
      .ship-card p {
          font-size: 0.9em;
      }
    }
  </style>
</head>
<body>

<div id="loadingOverlay">
    <div id="loadingMessage">Memuat...</div>
</div>

<div id="startScreen" class="show">
    <div class="ship-selection">
        <h2 style="font-size: 2em;">PILIH PESAWAT ANDA</h2>
        <div class="ship-options">
            <!-- Normal Ship -->
            <div class="ship-card" data-ship="normal">
                <img src="ship1.png" alt="Pesawat Normal">
                <h3>Viper</h3>
                <p>Tipe serba bisa, kecepatan normal.</p>
                <button class="select-button">Pilih</button>
            </div>
            <!-- Fast Ship -->
            <div class="ship-card" data-ship="fast">
                <img src="ship2.png" alt="Pesawat Cepat">
                <h3>Swiftwing</h3>
                <p>Kecepatan tinggi, tapi nyawa lebih sedikit.</p>
                <button class="select-button">Pilih</button>
            </div>
            <!-- Heavy Ship -->
            <div class="ship-card" data-ship="heavy">
                <img src="ship3.png" alt="Pesawat Berat">
                <h3>Bulwark</h3>
                <p>Lambat tapi nyawa lebih banyak.</p>
                <button class="select-button">Pilih</button>
            </div>
        </div>
    </div>
</div>

<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <div class="hud">Skor: <span id="scoreText">0</span></div>
  <div class="hud level-hud">Level: <span id="levelText">1</span></div>
  <div class="lives-hud">
    <span id="livesText"></span>
  </div>
  <div class="power-up-timer" id="rapidFireTimer">Tembak Cepat: <span id="rapidFireTime"></span></div>
  <div class="power-up-timer" id="shieldTimer">Perisai: <span id="shieldTime"></span></div>
  <div id="gameOverlay">
    <div id="overlayMessage"></div>
    <div id="overlayScore"></div>
    <button id="continueButton" style="display: none;">Lanjutkan</button>
    <button id="missionCompleteButton" style="display: none;">Ulangi Permainan</button>
    <button id="overlayRestart" style="display: none;">Mulai Ulang</button>
  </div>
</div>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const scoreText = document.getElementById("scoreText");
  const levelText = document.getElementById("levelText");
  const livesText = document.getElementById("livesText");
  const overlay = document.getElementById("gameOverlay");
  const overlayMessage = document.getElementById("overlayMessage");
  const overlayScore = document.getElementById("overlayScore");
  const overlayRestartButton = document.getElementById("overlayRestart");
  const missionCompleteButton = document.getElementById("missionCompleteButton");
  const continueButton = document.getElementById("continueButton");
  const rapidFireTimerEl = document.getElementById("rapidFireTimer");
  const shieldTimerEl = document.getElementById("shieldTimer");
  const rapidFireTimeEl = document.getElementById("rapidFireTime");
  const shieldTimeEl = document.getElementById("shieldTime");
  const loadingOverlay = document.getElementById("loadingOverlay");
  const gameContainer = document.getElementById("gameContainer");
  const startScreen = document.getElementById("startScreen");

  let width = window.innerWidth;
  let height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;

  const isMobile = () => /Mobi|Android/i.test(navigator.userAgent);
  const isDesktop = () => !isMobile();

  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    player.width = Math.min(width * 0.12, 120);
    player.height = Math.min(height * 0.08, 80);
    player.x = width / 2 - player.width / 2;
    player.y = height - player.height - 40;
  });

  const playerAssets = {
    normal: "ship1.png",
    fast: "ship2.png",
    heavy: "ship3.png"
  };

  const enemyAssets = [
    [ // Level 1 enemies
        "enemy1.png",
        "fast1.png"
    ],
    [ // Level 2 enemies
        "enemy2.png",
        "fast1.png"
    ],
    [ // Level 3 enemies
        "enemy3.png",
        "fast1.png"
    ],
    [ // Level 4 enemies
        "enemy4.png",
        "fast1.png"
    ]
  ];

  const bossAssets = [
    "boss1.png",
    "boss2.png",
    "boss3.png",
    "boss4.png"
  ];

  const rapidFireSVG = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="%23ffeb3b" /><path d="M 30,50 h 40 M 50,30 v 40" stroke="%23000" stroke-width="8" /></svg>';
  const shieldSVG = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M 10,50 A 40,40 0 0,1 90,50 A 40,40 0 0,1 50,90 A 40,40 0 0,1 10,50 Z" fill="%234caf50" stroke="%23fff" stroke-width="5" /></svg>';
  const healthSVG = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect x="10" y="40" width="80" height="20" fill="%23ff3333" /><rect x="40" y="10" width="20" height="80" fill="%23ff3333" /></svg>';
  const heartSVG = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M50 85c-15-20-30-35-30-45 0-10 10-20 20-20s20 10 20 20c0-10 10-20 20-20s20 10 20 20c0 10-15 25-30 45z" fill="%23ff3333" stroke="%23fff" stroke-width="3" /></svg>';
  const silentAudioDataURI = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
  const LaserURI = "Laser.mp3";
  const explodeURI = "explode.mp3";
  const powerupURI = "powerup.mp3";
  const damageURI = "damage.mp3";
  
  const assets = {};

  function loadAssets() {
      assets.playerImgs = {};
      for (const type in playerAssets) {
          assets.playerImgs[type] = new Image();
          assets.playerImgs[type].src = playerAssets[type];
      }
      
      assets.enemyImgs = enemyAssets.map(levelEnemies => 
          levelEnemies.map(url => {
              const img = new Image();
              img.src = url;
              return img;
          })
      );
      assets.bossImgs = bossAssets.map(url => {
          const img = new Image();
          img.src = url;
          return img;
      });
      
      assets.rapidFireImg = new Image();
      assets.rapidFireImg.src = rapidFireSVG;
      assets.shieldImg = new Image();
      assets.shieldImg.src = shieldSVG;
      assets.healthImg = new Image();
      assets.healthImg.src = healthSVG;
      assets.heartImg = new Image();
      assets.heartImg.src = heartSVG;
      
      assets.shootSound = new Audio(LaserURI);
      assets.explodeSound = new Audio(explodeURI);
      assets.powerupSound = new Audio(powerupURI);
      assets.damageSound = new Audio(damageURI);
      assets.healthSound = new Audio(powerupURI);
      
      assets.shootSound.volume = 0.5;
      assets.explodeSound.volume = 0.5;
      assets.powerupSound.volume = 0.5;
      assets.damageSound.volume = 0.5;
      assets.healthSound.volume = 0.5;

      loadingOverlay.style.opacity = '0';
      setTimeout(() => {
        loadingOverlay.style.display = 'none';
        startScreen.classList.add('show');
      }, 500);
  }
  
  loadAssets();


  const PLAYER_WIDTH = Math.min(width * 0.12, 120);
  const PLAYER_HEIGHT = Math.min(height * 0.08, 80);
  const ENEMY_WIDTH = Math.min(width * 0.1, 100);
  const ENEMY_HEIGHT = Math.min(height * 0.07, 70);
  const POWERUP_SIZE = Math.min(width * 0.08, 80);
  const BOSS_WIDTH = Math.min(width * 0.3, 300);
  const BOSS_HEIGHT = Math.min(height * 0.2, 200);
  const SHIELD_RADIUS = PLAYER_WIDTH * 0.7;

  let player = {
    x: width / 2 - PLAYER_WIDTH / 2,
    y: height - PLAYER_HEIGHT - 40,
    width: PLAYER_WIDTH,
    height: PLAYER_HEIGHT,
    speed: width * 0.015,
    shieldActive: false,
    rapidFireActive: false,
    type: 'normal'
  };

  let maxLives;
  let lives;
  let bullets = [];
  let enemies = [];
  let enemyBullets = [];
  let explosions = [];
  let boss = null;
  let bossBullets = [];
  let powerups = [];

  let score = 0;
  let gameOver = false;
  let paused = false; 
  let level = 1;
  let enemySpeedMultiplier = 1;
  let bossHpBase = 20;
  let animationFrameId;
  let lastBossScore = 0;

  let rapidFireTimer = 0;
  let shieldTimer = 0;
  let originalShootInterval = 300;
  let currentShootInterval = originalShootInterval;
  
  let shootTimeoutId = null;

  let isTouching = false;
  let touchStartX, touchStartY;
  
  canvas.addEventListener("touchstart", e => {
    e.preventDefault();
    if (paused || gameOver) return;
    isTouching = true;
    startShooting();
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  }, { passive: false });

  canvas.addEventListener("touchend", e => {
    e.preventDefault();
    isTouching = false;
    stopShooting();
  }, { passive: false });

  canvas.addEventListener("touchmove", e => {
    e.preventDefault();
    if (paused || gameOver) return;
    let touch = e.touches[0];
    let deltaX = touch.clientX - touchStartX;
    let deltaY = touch.clientY - touchStartY;
    player.x += deltaX;
    player.y += deltaY;
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;

    if (player.x < 0) player.x = 0;
    if (player.x + player.width > width) player.x = width - player.width;
    if (player.y < 0) player.y = 0;
    if (player.y + player.height > height) player.y = height - player.height;
  }, { passive: false });

  let keys = {};
  let isShooting = false;
  
  document.addEventListener("keydown", e => {
      keys[e.key] = true;
  });
  document.addEventListener("keyup", e => {
      delete keys[e.key];
  });
  
  canvas.addEventListener("mousemove", e => {
    if (isDesktop() && !paused && !gameOver) {
      player.x = e.clientX - player.width / 2;
      player.y = e.clientY - player.height / 2;
      
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > width) player.x = width - player.width;
      if (player.y < 0) player.y = 0;
      if (player.y + player.height > height) player.y = height - player.height;
    }
  });

  canvas.addEventListener("mousedown", e => {
    if (isDesktop() && !paused && !gameOver) {
      if (e.button === 0) { 
        startShooting();
      }
    }
  });
  
  canvas.addEventListener("mouseup", e => {
    if (isDesktop()) {
        stopShooting();
    }
  });
  
  document.addEventListener("keydown", e => {
    if (isDesktop() && (e.key === " " || e.key === "Enter") && !isShooting && !paused && !gameOver) {
      isShooting = true;
      startShooting();
    }
  });
  
  document.addEventListener("keyup", e => {
    if (isDesktop() && (e.key === " " || e.key === "Enter")) {
      isShooting = false;
      stopShooting();
    }
  });

  function handleMovement() {
    if (isDesktop()) {
      if (keys["ArrowLeft"] || keys["a"]) {
        player.x -= player.speed;
      }
      if (keys["ArrowRight"] || keys["d"]) {
        player.x += player.speed;
      }
      if (keys["ArrowUp"] || keys["w"]) {
        player.y -= player.speed;
      }
      if (keys["ArrowDown"] || keys["s"]) {
        player.y += player.speed;
      }
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > width) player.x = width - player.width;
      if (player.y < 0) player.y = 0;
      if (player.y + player.height > height) player.y = height - player.height;
    }
  }

  document.querySelectorAll('.select-button').forEach(button => {
      button.addEventListener('click', (e) => {
          const shipType = e.target.closest('.ship-card').dataset.ship;
          player.type = shipType;
          if (shipType === 'normal') {
              maxLives = 3;
              player.speed = width * 0.015;
          } else if (shipType === 'fast') {
              maxLives = 2;
              player.speed = width * 0.025;
          } else if (shipType === 'heavy') {
              maxLives = 5;
              player.speed = width * 0.01;
          }
          lives = maxLives;
          startScreen.classList.remove('show');
          startScreen.style.display = 'none';
          gameContainer.style.display = 'block';
          document.body.style.overflow = 'hidden'; 
          restartGame();
      });
  });

  continueButton.addEventListener('click', () => {
      paused = false;
      overlay.classList.remove('show');
      nextLevel();
      enemies = [];
      enemyBullets = [];
      bossBullets = [];
      boss = null;
      enemySpeedMultiplier += 0.2;
      bossHpBase += 10;
      update();
  });

  overlayRestartButton.addEventListener('click', () => {
      restartGame();
  });
  
  missionCompleteButton.addEventListener('click', () => {
    restartGame();
  });

  function shoot() {
      bullets.push({
          x: player.x + player.width * 0.25,
          y: player.y,
          width: 8,
          height: 20,
          speed: height * 0.02,
          color: "white"
      });
      bullets.push({
          x: player.x + player.width * 0.75 - 8,
          y: player.y,
          width: 8,
          height: 20,
          speed: height * 0.02,
          color: "white"
      });
      if (assets.shootSound) {
        assets.shootSound.currentTime = 0;
        assets.shootSound.play();
      }
  }
  
  function startShooting() {
    if (shootTimeoutId) return;
    shoot();
    shootTimeoutId = setInterval(shoot, currentShootInterval);
  }
  
  function stopShooting() {
      clearInterval(shootTimeoutId);
      shootTimeoutId = null;
  }

  function bossShoot() {
    if (boss && !gameOver && !paused) {
      bossBullets.push({
        x: boss.x + boss.width / 2 - 5,
        y: boss.y + boss.height,
        width: 10,
        height: 20,
        speed: height * 0.015
      });
    }
  }
  let bossShootInterval = setInterval(bossShoot, 500);

  function spawnEnemy() {
    if (!gameOver && !boss && !paused) {
      let x = Math.random() * (width - ENEMY_WIDTH);
      let y = 50 + Math.random() * 100;
      let type = Math.random() < 0.7 ? 'regular' : 'fast';
      let enemy = {
        x: x,
        y: y,
        width: ENEMY_WIDTH,
        height: ENEMY_HEIGHT,
        speed: (width * 0.005) * enemySpeedMultiplier,
        direction: Math.random() < 0.5 ? -1 : 1,
        type: type,
        phase: Math.random() * Math.PI * 2,
        img: assets.enemyImgs[level - 1][Math.floor(Math.random() * assets.enemyImgs[level - 1].length)]
      };
      if (type === 'fast') {
          enemy.speed *= 1.5;
      }
      enemies.push(enemy);
    }
  }
  let enemySpawnInterval = setInterval(spawnEnemy, 2000);

  function enemyShoot() {
    if (!gameOver && !paused && enemies.length > 0) {
      enemies.forEach(e => {
        if (Math.random() < 0.15) { 
          enemyBullets.push({
            x: e.x + e.width / 2 - 5,
            y: e.y + e.height,
            width: 8,
            height: 16,
            speed: height * 0.01
          });
        }
      });
    }
  }
  let enemyShootInterval = setInterval(enemyShoot, 100);

  function spawnPowerup() {
      if (!gameOver && !boss && !paused && Math.random() < 0.3) {
          let type;
          let random = Math.random();
          if (random < 0.4) {
              type = 'rapidFire';
          } else if (random < 0.8) {
              type = 'shield';
          } else {
              type = 'health';
          }
          powerups.push({
              x: Math.random() * (width - POWERUP_SIZE),
              y: -POWERUP_SIZE,
              width: POWERUP_SIZE,
              height: POWERUP_SIZE,
              speed: height * 0.005,
              type: type
          });
      }
  }
  let powerupSpawnInterval = setInterval(spawnPowerup, 3000);

  function addExplosion(x, y, size = ENEMY_WIDTH) {
    explosions.push({
      x: x,
      y: y,
      frame: 0,
      maxFrame: 10,
      size: size
    });
    if (assets.explodeSound) {
        assets.explodeSound.currentTime = 0;
        assets.explodeSound.play();
    }
  }

  function drawLives() {
      livesText.innerHTML = ''; 
      for (let i = 0; i < lives; i++) {
          const heart = document.createElement('img');
          heart.src = assets.heartImg.src;
          heart.classList.add('heart');
          livesText.appendChild(heart);
      }
  }

  function playerDamage() {
    if (player.shieldActive) {
      player.shieldActive = false;
      if (assets.damageSound) {
        assets.damageSound.currentTime = 0;
        assets.damageSound.play();
      }
      return; 
    }
    
    lives--;
    if (assets.damageSound) {
        assets.damageSound.currentTime = 0;
        assets.damageSound.play();
    }
    drawLives();

    if (lives <= 0) {
      addExplosion(player.x, player.y, player.width);
      showGameOver();
    }
  }
  
  function showGameOver() {
    gameOver = true;
    cancelAnimationFrame(animationFrameId);
    overlayMessage.textContent = "GAME OVER";
    overlayScore.textContent = "Skor: " + score;
    overlayRestartButton.style.display = 'block';
    continueButton.style.display = 'none';
    missionCompleteButton.style.display = 'none';
    overlay.classList.add('show');
  }
  
  function showMissionComplete() {
    gameOver = true;
    cancelAnimationFrame(animationFrameId);
    overlayMessage.textContent = "MISSION COMPLETE!";
    overlayScore.textContent = "Skor Akhir: " + score;
    overlayRestartButton.style.display = 'none';
    continueButton.style.display = 'none';
    missionCompleteButton.style.display = 'block';
    overlay.classList.add('show');
  }

  function showContinueOverlay() {
    paused = true;
    overlayMessage.textContent = "Boss Terkalahkan!";
    overlayScore.textContent = `Skor: ${score}`;
    overlayRestartButton.style.display = 'none';
    missionCompleteButton.style.display = 'none';
    continueButton.style.display = 'block';
    overlay.classList.add('show');
  }

  function nextLevel() {
    if (level < 4) {
        level++;
        levelText.textContent = level;
        enemies = [];
        enemyBullets = [];
        enemySpeedMultiplier += 0.2; 
        bossHpBase += 10;
        lastBossScore = score;
    } else {
        showMissionComplete();
    }
  }

  function spawnBoss() {
    if (!boss && level <= 4) {
        let bossImgIndex = Math.min(level - 1, assets.bossImgs.length - 1);
        boss = {
            x: width / 2 - BOSS_WIDTH / 2,
            y: 50,
            width: BOSS_WIDTH,
            height: BOSS_HEIGHT,
            hp: bossHpBase,
            direction: 1,
            speed: width * 0.005,
            img: assets.bossImgs[bossImgIndex]
        };
    }
  }

  function restartGame() {
    score = 0;
    level = 1;
    lives = maxLives;
    enemySpeedMultiplier = 1;
    bossHpBase = 20;
    enemies = [];
    bullets = [];
    enemyBullets = [];
    bossBullets = [];
    explosions = [];
    boss = null;
    powerups = [];
    gameOver = false;
    paused = false;
    lastBossScore = 0;
    player.x = width / 2 - PLAYER_WIDTH / 2;
    player.y = height - player.height - 40;
    player.shieldActive = false;
    player.rapidFireActive = false;
    rapidFireTimer = 0;
    shieldTimer = 0;
    currentShootInterval = originalShootInterval;
    rapidFireTimerEl.classList.remove('show');
    shieldTimerEl.classList.remove('show');

    scoreText.textContent = score;
    levelText.textContent = level;
    drawLives();
    overlay.classList.remove('show');
    overlayRestartButton.style.display = 'none';
    
    update();
  }

  function update() {
    if (paused) {
        animationFrameId = requestAnimationFrame(update);
        return;
    }

    ctx.clearRect(0, 0, width, height);
    
    drawStars();
    
    handleMovement();

    if (!gameOver) {
      if (player.shieldActive) {
        ctx.beginPath();
        ctx.arc(player.x + player.width / 2, player.y + player.height / 2, SHIELD_RADIUS, 0, 2 * Math.PI);
        ctx.fillStyle = `rgba(76, 175, 80, ${Math.sin(Date.now() / 300) * 0.2 + 0.6})`;
        ctx.fill();
      }
      ctx.drawImage(assets.playerImgs[player.type], player.x, player.y, player.width, player.height);
    }
    
    for (let i = powerups.length - 1; i >= 0; i--) {
        let p = powerups[i];
        p.y += p.speed;
        let img;
        if (p.type === 'rapidFire') {
            img = assets.rapidFireImg;
        } else if (p.type === 'shield') {
            img = assets.shieldImg;
        } else if (p.type === 'health') {
            img = assets.healthImg;
        }
        ctx.drawImage(img, p.x, p.y, p.width, p.height);

        if (p.y > height) {
            powerups.splice(i, 1);
        }

        if (
            player.x < p.x + p.width && player.x + player.width > p.x &&
            player.y < p.y + p.height && player.y + player.height > p.y
        ) {
            if (p.type === 'rapidFire') {
                player.rapidFireActive = true;
                currentShootInterval = 100;
                rapidFireTimer = 10;
                if (assets.powerupSound) assets.powerupSound.play();
            } else if (p.type === 'shield') {
                player.shieldActive = true;
                shieldTimer = 15;
                if (assets.powerupSound) assets.powerupSound.play();
            } else if (p.type === 'health') {
                if (lives < maxLives) {
                    lives++;
                    drawLives();
                    if (assets.healthSound) assets.healthSound.play();
                }
            }
            powerups.splice(i, 1);
        }
    }
    
    if (player.rapidFireActive) {
        rapidFireTimer -= 1/60;
        rapidFireTimeEl.textContent = rapidFireTimer.toFixed(1);
        rapidFireTimerEl.classList.add('show');
        if (rapidFireTimer <= 0) {
            player.rapidFireActive = false;
            currentShootInterval = originalShootInterval;
            rapidFireTimerEl.classList.remove('show');
        }
    } else {
        rapidFireTimerEl.classList.remove('show');
    }
    
    if (player.shieldActive) {
        shieldTimer -= 1/60;
        shieldTimeEl.textContent = shieldTimer.toFixed(1);
        shieldTimerEl.classList.add('show');
        if (shieldTimer <= 0) {
            player.shieldActive = false;
            shieldTimerEl.classList.remove('show');
        }
    } else {
        shieldTimerEl.classList.remove('show');
    }

    for (let i = bullets.length - 1; i >= 0; i--) {
      let b = bullets[i];
      b.y -= b.speed;
      
      ctx.beginPath();
      ctx.moveTo(b.x + b.width / 2, b.y);
      ctx.lineTo(b.x + b.width / 2, b.y + b.height);
      ctx.lineWidth = b.width;
      ctx.strokeStyle = `white`;
      ctx.shadowBlur = 10;
      ctx.shadowColor = `cyan`;
      ctx.stroke();
      ctx.shadowBlur = 0;

      if (b.y + b.height < 0) {
        bullets.splice(i, 1);
      }
    }

    for (let i = enemies.length - 1; i >= 0; i--) {
      let e = enemies[i];
      if (e.type === 'regular') {
          e.x += e.direction * e.speed;
          if (e.x <= 0 || e.x + e.width >= width) {
            e.direction *= -1;
          }
      } else if (e.type === 'fast') {
          e.x += Math.sin(e.phase) * e.speed;
          e.y += e.speed / 2;
          e.phase += 0.05;
      }
      
      ctx.drawImage(e.img, e.x, e.y, e.width, e.height);

      for (let j = bullets.length - 1; j >= 0; j--) {
        let b = bullets[j];
        if (
          b.x < e.x + e.width && b.x + b.width > e.x &&
          b.y < e.y + e.height && b.y + b.height > e.y
        ) {
          addExplosion(e.x, e.y);
          enemies.splice(i, 1);
          bullets.splice(j, 1);
          score += 10;
          scoreText.textContent = score;
          
          if (score >= lastBossScore + 200 && level <= 4) {
            spawnBoss();
            lastBossScore = score;
          }
          break;
        }
      }

      if (
        player.x < e.x + e.width && player.x + player.width > e.x &&
        player.y < e.y + e.height && player.y + player.height > e.y
      ) {
        playerDamage();
        enemies.splice(i, 1);
      }
    }

    if (boss) {
      boss.x += boss.direction * boss.speed;
      if (boss.x <= 0 || boss.x + boss.width >= width) boss.direction *= -1;

      ctx.drawImage(boss.img, boss.x, boss.y, boss.width, boss.height);

      ctx.fillStyle = "red";
      ctx.fillRect(boss.x, boss.y - 10, boss.width, 8);
      ctx.fillStyle = "lime";
      ctx.fillRect(boss.x, boss.y - 10, (boss.hp / bossHpBase) * boss.width, 8);

      for (let j = bullets.length - 1; j >= 0; j--) {
        let b = bullets[j];
        if (
          b.x < boss.x + boss.width && b.x + b.width > boss.x &&
          b.y < boss.y + boss.height && b.y + b.height > boss.y
        ) {
          bullets.splice(j, 1);
          boss.hp--;
          if (boss.hp <= 0) {
            addExplosion(boss.x, boss.y, boss.width);
            score += 50;
            scoreText.textContent = score;
            boss = null;
            showContinueOverlay();
          }
          break;
        }
      }

      if (
        player.x < boss.x + boss.width && player.x + player.width > boss.x &&
        player.y < boss.y + player.height && player.y + player.height > boss.y
      ) {
        playerDamage();
        if (lives > 0) {
            addExplosion(boss.x, boss.y, boss.width);
        }
      }
    }

    const enemyBulletCheck = (b) => {
        b.y += b.speed;
        ctx.fillStyle = "orange";
        ctx.shadowBlur = 10;
        ctx.shadowColor = `white`;
        if (b.y > height) {
            return true;
        }
        if (
            player.x < b.x + b.width && player.x + player.width > b.x &&
            player.y < b.y + b.height && player.y + player.height > b.y
        ) {
            playerDamage();
            return true;
        }
        ctx.fillRect(b.x, b.y, b.width, b.height);
        return false;
    };
    
    enemyBullets = enemyBullets.filter(b => !enemyBulletCheck(b));
    bossBullets = bossBullets.filter(b => !enemyBulletCheck(b));

    for (let i = explosions.length - 1; i >= 0; i--) {
      let ex = explosions[i];
      ctx.beginPath();
      ctx.arc(ex.x + ex.size / 2, ex.y + ex.size / 2, ex.size * (ex.frame / ex.maxFrame) / 2, 0, 2 * Math.PI);
      ctx.fillStyle = `rgba(255, 100, 0, ${1 - ex.frame / ex.maxFrame})`;
      ctx.fill();
      ex.frame++;
      if (ex.frame >= ex.maxFrame) {
        explosions.splice(i, 1);
      }
    }

    if (!gameOver) {
      animationFrameId = requestAnimationFrame(update);
    }
  }

  let stars = [];
  const starCount = 200;
  for (let i = 0; i < starCount; i++) {
    stars.push({
      x: Math.random() * width,
      y: Math.random() * height,
      size: Math.random() * 2 + 1,
      speed: Math.random() * 0.5 + 0.5
    });
  }
  function drawStars() {
    ctx.fillStyle = "#fff";
    for (let i = 0; i < stars.length; i++) {
      let star = stars[i];
      ctx.fillRect(star.x, star.y, star.size, star.size);
      star.y += star.speed;
      if (star.y > height) {
        star.y = 0;
        star.x = Math.random() * width;
      }
    }
  }
</script>
</body>
</html>
